# 面试问题收集汇总
## cpp
### C++ extern
**外部变量声明**
当需要在多个源文件中使用同一个全局变量时，可以使用extern关键字来声明该变量，而不重新定义它。
```cpp
#include <iostream>

// 声明全局变量
extern int globalVariable;

int main() {
    std::cout << "globalVariable: " << globalVariable << std::endl;
    return 0;
}
```

**外部函数声明**
extern也可以用于函数声明，尽管一般情况下我们不需要显式地使用它，因为函数声明本身就是外部链接的。

**C和C++混合编程**
在C++程序中调用C函数时，extern "C"关键字非常有用。它告诉C++编译器以C语言的方式来处理这些函数名，以避免由于C++的名称修饰（name mangling）带来的链接问题。
```cpp
#include <iostream>

// 告诉编译器以C语言方式处理函数名
extern "C" {
    #include "example.h"
}

int main() {
    cFunction();
    return 0;
}
```



## planning
### 坐标转换
#### 四元数的表示、逆运算、加、旋转

### 完备性、概率完备性、最优性、渐进最优性
**完备性**：完备性是指一种算法在给定足够的时间和资源的情况下，如果存在解，它一定能够找到解。也就是说，完备的算法不会错过任何可能的解。（BFS）
**概率完备性**：概率完备性是指一种算法在给定足够的时间和资源的情况下，如果存在解，它能够找到一个最优的解。（RRT）
**最优性**：最优性是指一种算法如果找到了解，它保证这个解是最优解，即在所有可能的解中，代价（如路径长度、时间等）是最小的。Dijkstra算法和A*算法（**启发式函数小于等于真实的代价**）是最优的，因为它们找到的路径保证是最短路径。
**渐进最优性**：是指一种算法随着时间的推移，其找到的解逐渐趋向于最优解。尽管在有限时间内可能找到的解不是最优的，但随着搜索时间的增加，解的质量逐渐接近最优。
举例：快速探索随机树（RRT*）是一种渐进最优的算法，因为它在初始阶段可能找到一个次优解，但通过不断地重新连线和优化路径，最终解会逐渐接近最优解。

### 搜索算法
#### Dijkstra和A*都具有完备性、最优性吗？Dijkstra算法需要维护每个节点到终点的代价？
**Dijkstra**

完备性（Completeness）
Dijkstra算法是完备的。它通过逐步扩展每个节点并更新其邻居节点的最短路径代价，最终确保找到从起点到所有其他节点的最短路径。如果存在从起点到目标节点的路径，Dijkstra算法一定会找到它。
最优性（Optimality）
Dijkstra算法是最优的。它总是找到从起点到目标节点的最短路径。由于它使用一个优先队列来处理节点，并且总是选择当前已知最短路径进行扩展，所以保证了最优解的正确性。

**A***
完备性（Completeness）
A算法在使用可容许（admissible）和一致（consistent, 也称单调的）启发式函数时是完备的。如果存在从起点到目标节点的路径，A算法一定会找到它。
最优性（Optimality）
A*算法在使用可容许和一致的启发式函数时也是最优的。它结合了从起点到当前节点的实际代价和从当前节点到目标节点的估计代价，通过优先扩展总代价最小的节点来保证找到最优路径。

#### weighted-A*只能找到次优解，但是快？
Weighted A*（加权A*）算法是一种A算法的变种，通过引入一个权重参数来加快搜索速度。它在启发式函数中引入一个权重因子，使得搜索过程更加贪婪，从而可能会找到次优解，但通常会更快地找到一个解。

### 优化算法
#### 凸函数乘凸函数， 封闭多边形是凸的充要条件， 凸包的交集是凸的吗
在讨论凸函数、凸多边形和凸包时，需要注意它们之间的不同性质：
**凸函数乘凸函数**：   

如果两个函数都是凸函数，它们的乘积不一定是凸函数。凸函数的乘积可能是非凸的，这是因为凸函数的乘积可能会产生非线性项，导致函数曲线出现凹陷部分，从而不满足凸函数的定义。

**封闭多边形是凸的充要条件**：   

封闭多边形是凸的充要条件是指，一个多边形是凸多边形当且仅当它的每一条线段上的点都在多边形内部。换句话说，对于任意两点在多边形内的封闭路径，该路径上的所有点都在多边形内部。这是凸多边形的一个基本特性。

**凸包的交集是凸的吗**：   

凸包的交集在一般情况下不一定是凸的。具体而言，如果凸包的交集是两个非凸集合的交集，那么它不一定是凸的。然而，如果凸包的交集是两个凸集合的交集，那么它是凸的。这是因为凸集合的交集仍然保持凸性质。

#### 拟牛顿法，回退法，精确罚函数，增广拉格朗日法和二次罚函数
**拟牛顿法（Quasi-Newton Methods）**： 拟牛顿法是一种迭代优化算法，用于求解无约束优化问题。它通过逐步逼近目标函数的二阶导数信息来更新搜索方向，从而快速收敛到局部最优解。拟牛顿法的基本思想是使用一个近似的Hessian矩阵来代替真实的Hessian矩阵，从而避免了每次迭代都需要计算二阶导数的复杂性。

**回退法（Backtracking Line Search）**： 回退法是一种用于确定步长（即步伐大小）的搜索方法，通常用于梯度下降等迭代优化算法中。在每次迭代中，回退法会首先选择一个较大的初始步长，然后逐步减小步长，直到满足一定的收敛条件为止。回退法的目的是确保每次迭代朝着目标函数下降的方向移动，并且不会过度步长以至于无法收敛。

**精确罚函数（Exact Penalty Function）**： 精确罚函数是一种用于处理约束优化问题的方法，它通过引入罚项来将约束条件纳入目标函数中。精确罚函数方法通过将罚项加到目标函数中，使得违反约束条件的解变得不可行，并且通过调整罚项的大小来控制约束条件的影响。

**增广拉格朗日法（Augmented Lagrangian Method）**： 增广拉格朗日法是一种用于求解约束优化问题的方法，它通过将拉格朗日乘子法和精确罚函数方法结合起来，解决了传统拉格朗日乘子法收敛速度慢、精确罚函数方法求解过程中罚参数不易选择的问题。增广拉格朗日法在每次迭代中都会更新拉格朗日乘子和罚参数，以加速收敛并提高数值稳定性。

**二次罚函数（Quadratic Penalty Function）**： 二次罚函数是一种特殊的精确罚函数，它将约束条件转化为罚项，并且将罚项设置为二次函数的形式。二次罚函数方法通过添加二次罚项到目标函数中来惩罚违反约束条件的解，从而将约束优化问题转化为无约束优化问题。

#### 基于优化的路径规划，凸优化问题求解的局部最优不一定是全局最优？
凸优化问题是一类具有凸目标函数和凸约束条件的优化问题，它们具有良好的性质，例如局部最优解也是全局最优解的性质。但是，在实际应用中，路径规划问题通常还涉及到非凸的约束条件和目标函数，这会导致局部最优解与全局最优解的不同。特别是在复杂的环境中，例如包含障碍物的场景或多目标优化问题中，凸优化问题往往难以找到全局最优解。局部最优解可能会被障碍物或局部极小点所困，而无法达到全局最优解。因此，对于基于优化的路径规划算法，需要谨慎选择目标函数和约束条件，并采用适当的优化技术来尽可能地避免局部最优解，以便接近或找到全局最优解。例如，可以使用全局优化算法、多启发式函数、启发式搜索策略等来提高算法的全局搜索能力，以更好地解决路径规划问题。

#### SCP(Sequential Convex Programming)可以找到全局最优解吗？
SCP（Sequential Convex Programming）是一种用于非凸优化问题的逐步优化方法，它将原始非凸优化问题分解为一系列凸优化子问题，并通过逐步求解这些凸优化子问题来逼近原始非凸优化问题的解。SCP方法在每个迭代步骤中，将原始非凸优化问题在当前解点处进行线性化，得到一个凸优化子问题，然后解决这个凸优化子问题以更新当前解。通过迭代求解一系列凸优化子问题，SCP方法试图找到原始非凸优化问题的局部最优解。然而，值得注意的是，SCP方法并不能保证找到原始非凸优化问题的全局最优解。因为SCP方法是基于局部线性化的策略，它只能找到局部最优解，而无法保证这些局部最优解是全局最优解。SCP方法常常用于求解大规模、复杂的非凸优化问题，它能够在可接受的时间内找到高质量的解，但不能保证全局最优性。

#### 判断正误
梯度下降 (Gradient Descent, GD)以当前位置的梯度为搜索方向，是一阶收敛的
牛顿法是二阶收敛的
共轭梯度法可以在有限步数迭代收敛到极值
牛顿法中的hessian矩阵难以计算，可以采用拟牛顿法

## ROS


## prediction