# 面试问题收集汇总
## cpp
### C++ extern
**外部变量声明**
当需要在多个源文件中使用同一个全局变量时，可以使用extern关键字来声明该变量，而不重新定义它。
```cpp
#include <iostream>

// 声明全局变量
extern int globalVariable;

int main() {
    std::cout << "globalVariable: " << globalVariable << std::endl;
    return 0;
}
```

**外部函数声明**
extern也可以用于函数声明，尽管一般情况下我们不需要显式地使用它，因为函数声明本身就是外部链接的。

**C和C++混合编程**
在C++程序中调用C函数时，extern "C"关键字非常有用。它告诉C++编译器以C语言的方式来处理这些函数名，以避免由于C++的名称修饰（name mangling）带来的链接问题。
```cpp
#include <iostream>

// 告诉编译器以C语言方式处理函数名
extern "C" {
    #include "example.h"
}

int main() {
    cFunction();
    return 0;
}
```



## planning
### 数学
#### 四元数的表示、逆运算、加、旋转

#### KD tree


#### 范数
在不同的应用场景中，有几种常用的范数：

1. **欧几里得范数（Euclidean Norm）或 \( L^2 \) 范数**：
   - 定义：对于向量 \( \mathbf{x} = (x_1, x_2, \dots, x_n) \in \mathbb{R}^n \)，欧几里得范数定义为：
     \[
     \|\mathbf{x}\|_2 = \sqrt{x_1^2 + x_2^2 + \dots + x_n^2}
     \]
   - 这个范数就是我们通常理解的“长度”或“距离”。

2. **曼哈顿范数（Manhattan Norm）或 \( L^1 \) 范数**：
   - 定义：对于向量 \( \mathbf{x} = (x_1, x_2, \dots, x_n) \in \mathbb{R}^n \)，曼哈顿范数定义为：
     \[
     \|\mathbf{x}\|_1 = |x_1| + |x_2| + \dots + |x_n|
     \]
   - 这个范数衡量的是“直角距离”或“城市街区距离”，即沿坐标轴方向的距离总和。

3. **最大范数（Maximum Norm）或 \( L^\infty \) 范数**：
   - 定义：对于向量 \( \mathbf{x} = (x_1, x_2, \dots, x_n) \in \mathbb{R}^n \)，最大范数定义为：
     \[
     \|\mathbf{x}\|_\infty = \max \{ |x_1|, |x_2|, \dots, |x_n| \}
     \]
   - 这个范数衡量的是向量中最大绝对值的元素。

4. **\( p \) 范数（\( L^p \) Norm）**：
   - 定义：对于向量 \( \mathbf{x} = (x_1, x_2, \dots, x_n) \in \mathbb{R}^n \) 和 \( p \geq 1 \)，\( p \) 范数定义为：
     \[
     \|\mathbf{x}\|_p = \left( |x_1|^p + |x_2|^p + \dots + |x_n|^p \right)^{\frac{1}{p}}
     \]
   - 当 \( p = 2 \) 时，得到的是欧几里得范数；当 \( p = 1 \) 时，得到的是曼哈顿范数；当 \( p \to \infty \) 时，得到的是最大范数。

### 完备性、概率完备性、最优性、渐进最优性
**完备性**：完备性是指一种算法在给定足够的时间和资源的情况下，如果存在解，它一定能够找到解。也就是说，完备的算法不会错过任何可能的解。（BFS）
**概率完备性**：概率完备性是指一种算法在给定足够的时间和资源的情况下，如果存在解，它能够找到一个最优的解。（RRT）
**最优性**：最优性是指一种算法如果找到了解，它保证这个解是最优解，即在所有可能的解中，代价（如路径长度、时间等）是最小的。Dijkstra算法和A*算法（**启发式函数小于等于真实的代价**）是最优的，因为它们找到的路径保证是最短路径。
**渐进最优性**：是指一种算法随着时间的推移，其找到的解逐渐趋向于最优解。尽管在有限时间内可能找到的解不是最优的，但随着搜索时间的增加，解的质量逐渐接近最优。
举例：快速探索随机树（RRT*）是一种渐进最优的算法，因为它在初始阶段可能找到一个次优解，但通过不断地重新连线和优化路径，最终解会逐渐接近最优解。

### 搜索算法
#### Dijkstra和A*都具有完备性、最优性吗？Dijkstra算法需要维护每个节点到终点的代价？
**Dijkstra**

完备性（Completeness）
Dijkstra算法是完备的。它通过逐步扩展每个节点并更新其邻居节点的最短路径代价，最终确保找到从起点到所有其他节点的最短路径。如果存在从起点到目标节点的路径，Dijkstra算法一定会找到它。
最优性（Optimality）
Dijkstra算法是最优的。它总是找到从起点到目标节点的最短路径。由于它使用一个优先队列来处理节点，并且总是选择当前已知最短路径进行扩展，所以保证了最优解的正确性。

**A***
完备性（Completeness）
A算法在使用可容许（admissible）和一致（consistent, 也称单调的）启发式函数时是完备的。如果存在从起点到目标节点的路径，A算法一定会找到它。
最优性（Optimality）
A*算法在使用可容许和一致的启发式函数时也是最优的。它结合了从起点到当前节点的实际代价和从当前节点到目标节点的估计代价，通过优先扩展总代价最小的节点来保证找到最优路径。

#### weighted-A*只能找到次优解，但是快？
Weighted A*（加权A*）算法是一种A算法的变种，通过引入一个权重参数来加快搜索速度。它在启发式函数中引入一个权重因子，使得搜索过程更加贪婪，从而可能会找到次优解，但通常会更快地找到一个解。

### 优化算法
#### 凸函数乘凸函数， 封闭多边形是凸的充要条件， 凸包的交集是凸的吗
在讨论凸函数、凸多边形和凸包时，需要注意它们之间的不同性质：
**凸函数乘凸函数**：   

如果两个函数都是凸函数，它们的乘积不一定是凸函数。凸函数的乘积可能是非凸的，这是因为凸函数的乘积可能会产生非线性项，导致函数曲线出现凹陷部分，从而不满足凸函数的定义。

**封闭多边形是凸的充要条件**：   

封闭多边形是凸的充要条件是指，一个多边形是凸多边形当且仅当它的每一条线段上的点都在多边形内部。换句话说，对于任意两点在多边形内的封闭路径，该路径上的所有点都在多边形内部。这是凸多边形的一个基本特性。

**凸包的交集是凸的吗**：   

凸包的交集在一般情况下不一定是凸的。具体而言，如果凸包的交集是两个非凸集合的交集，那么它不一定是凸的。然而，如果凸包的交集是两个凸集合的交集，那么它是凸的。这是因为凸集合的交集仍然保持凸性质。

#### 拟牛顿法，回退法，精确罚函数，增广拉格朗日法和二次罚函数
**拟牛顿法（Quasi-Newton Methods）**： 拟牛顿法是一种迭代优化算法，用于求解无约束优化问题。它通过逐步逼近目标函数的二阶导数信息来更新搜索方向，从而快速收敛到局部最优解。拟牛顿法的基本思想是使用一个近似的Hessian矩阵来代替真实的Hessian矩阵，从而避免了每次迭代都需要计算二阶导数的复杂性。

**回退法（Backtracking Line Search）**： 回退法是一种用于确定步长（即步伐大小）的搜索方法，通常用于梯度下降等迭代优化算法中。在每次迭代中，回退法会首先选择一个较大的初始步长，然后逐步减小步长，直到满足一定的收敛条件为止。回退法的目的是确保每次迭代朝着目标函数下降的方向移动，并且不会过度步长以至于无法收敛。

**精确罚函数（Exact Penalty Function）**： 精确罚函数是一种用于处理约束优化问题的方法，它通过引入罚项来将约束条件纳入目标函数中。精确罚函数方法通过将罚项加到目标函数中，使得违反约束条件的解变得不可行，并且通过调整罚项的大小来控制约束条件的影响。

**增广拉格朗日法（Augmented Lagrangian Method）**： 增广拉格朗日法是一种用于求解约束优化问题的方法，它通过将拉格朗日乘子法和精确罚函数方法结合起来，解决了传统拉格朗日乘子法收敛速度慢、精确罚函数方法求解过程中罚参数不易选择的问题。增广拉格朗日法在每次迭代中都会更新拉格朗日乘子和罚参数，以加速收敛并提高数值稳定性。

**二次罚函数（Quadratic Penalty Function）**： 二次罚函数是一种特殊的精确罚函数，它将约束条件转化为罚项，并且将罚项设置为二次函数的形式。二次罚函数方法通过添加二次罚项到目标函数中来惩罚违反约束条件的解，从而将约束优化问题转化为无约束优化问题。

#### 基于优化的路径规划，凸优化问题求解的局部最优不一定是全局最优？
凸优化问题是一类具有凸目标函数和凸约束条件的优化问题，它们具有良好的性质，例如局部最优解也是全局最优解的性质。但是，在实际应用中，路径规划问题通常还涉及到非凸的约束条件和目标函数，这会导致局部最优解与全局最优解的不同。特别是在复杂的环境中，例如包含障碍物的场景或多目标优化问题中，凸优化问题往往难以找到全局最优解。局部最优解可能会被障碍物或局部极小点所困，而无法达到全局最优解。因此，对于基于优化的路径规划算法，需要谨慎选择目标函数和约束条件，并采用适当的优化技术来尽可能地避免局部最优解，以便接近或找到全局最优解。例如，可以使用全局优化算法、多启发式函数、启发式搜索策略等来提高算法的全局搜索能力，以更好地解决路径规划问题。

#### SCP(Sequential Convex Programming)可以找到全局最优解吗？
SCP（Sequential Convex Programming）是一种用于非凸优化问题的逐步优化方法，它将原始非凸优化问题分解为一系列凸优化子问题，并通过逐步求解这些凸优化子问题来逼近原始非凸优化问题的解。SCP方法在每个迭代步骤中，将原始非凸优化问题在当前解点处进行线性化，得到一个凸优化子问题，然后解决这个凸优化子问题以更新当前解。通过迭代求解一系列凸优化子问题，SCP方法试图找到原始非凸优化问题的局部最优解。然而，值得注意的是，SCP方法并不能保证找到原始非凸优化问题的全局最优解。因为SCP方法是基于局部线性化的策略，它只能找到局部最优解，而无法保证这些局部最优解是全局最优解。SCP方法常常用于求解大规模、复杂的非凸优化问题，它能够在可接受的时间内找到高质量的解，但不能保证全局最优性。

#### 判断正误
梯度下降 (Gradient Descent, GD)以当前位置的梯度为搜索方向，是一阶收敛的
牛顿法是二阶收敛的
共轭梯度法可以在有限步数迭代收敛到极值
牛顿法中的hessian矩阵难以计算，可以采用拟牛顿法

## ROS
### ROS 通信
#### 主题
主题是ROS中一种基于发布-订阅模式的通信机制，允许节点（Nodes）之间交换消息（Messages）。

节点（Nodes）：在ROS中，节点是执行任务的基本单位。每个节点通常执行特定的功能，比如传感器数据读取、运动控制等。
消息（Messages）：ROS中的消息是节点之间交换数据的基本单位。消息具有特定的结构，包含多个字段，字段可以是基本类型（如整数、浮点数）或复杂类型（如数组、字符串）。
主题（Topics）：主题是消息传递的通道。每个主题都有一个唯一的名字，用于标识消息的类型和内容。节点可以通过发布（Publish）或订阅（Subscribe）主题来发送或接收消息。
发布者（Publisher）和订阅者（Subscriber）：
发布者：节点通过创建发布者对象来发布消息，发布者将消息发送到某个主题。
订阅者：节点通过创建订阅者对象来订阅主题，订阅者会收到该主题的所有消息。
ROS Master：ROS Master 是整个ROS网络中的一个注册和查询服务。它负责跟踪所有节点、主题、服务等的信息。当节点创建发布者或订阅者时，它会向ROS Master注册，ROS Master会帮助匹配发布者和订阅者。
**主题通信的基本过程**
发布者创建：节点A创建一个发布者对象，并注册到ROS Master。
订阅者创建：节点B创建一个订阅者对象，并注册到ROS Master。
匹配：ROS Master匹配该主题的发布者和订阅者，并告知彼此的存在。
消息传递：节点A发布消息，ROS会通过主题将消息传递给节点B的订阅者。
接收消息：节点B通过订阅者对象接收来自节点A的消息，并执行相关的处理逻辑。
**注意事项**
命名规范：
确保主题名称是唯一的，使用符合规范的名称，避免名称冲突。
使用分层次的命名方式，如 /sensor/temperature，以便更好地组织和管理主题。
同步问题：
如果发布者发布消息的速度过快，而订阅者处理不过来，可能会导致消息积压。可以通过设置消息队列大小来控制。
消息类型匹配：
发布者和订阅者的消息类型必须完全匹配，否则无法通信。
网络延迟和丢包：
在分布式系统中，网络延迟和丢包是不可避免的。需要设计系统时考虑这些因素，可能需要使用更可靠的通信机制。
资源管理：
控制发布者和订阅者的数量，避免资源浪费。对于频繁通信的主题，可以考虑合并消息或降低发布频率。
ROS Master的单点故障：
ROS Master是整个系统的核心，如果它出现问题，整个通信网络可能会瘫痪。可以考虑使用多主（multi-master）方案来提高系统的可靠性。
### 服务
服务（Services）。服务是一种基于请求-响应模式的同步通信方式，适用于那些需要节点之间进行明确的请求和响应操作的场景。
**服务通信的过程和原理**
在ROS中，服务是一种双向通信机制，允许一个节点发送请求给另一个节点，并等待响应。服务通常用于执行某些特定的操作，例如启动某个行为、获取某种数据等。
服务由两部分组成：请求（Request）和响应（Response）。请求部分包含客户端发送的数据，而响应部分包含服务端返回的数据。
服务服务器（Service Server）：
- 服务服务器是提供服务的节点。它注册一个服务，并等待来自其他节点的请求。当接收到请求时，服务服务器执行相应的操作，并返回结果。

服务客户端（Service Client）：
- 服务客户端是请求服务的节点。它向服务服务器发送请求，并等待服务器的响应。客户端发送请求时，会阻塞，直到收到服务器的响应。

ROS Master：
- ROS Master在服务通信中也扮演了关键角色。它负责跟踪和管理所有服务的注册信息。当客户端需要调用服务时，它会通过ROS Master查找到相应的服务服务器。

**服务通信的基本过程**
服务定义：
- 服务通常通过ROS中.srv文件定义。该文件描述了请求和响应的数据结构。例如，一个求和服务可能定义为两个整数的请求和一个整数的响应。
  
服务服务器创建：
- 节点A创建并注册一个服务服务器，向ROS Master注册该服务的名称和处理函数。

服务客户端创建：
- 节点B创建一个服务客户端，指定要调用的服务名称。

请求-响应过程：
- 节点B通过客户端向节点A发送请求。节点A接收到请求后，执行相应的操作并返回结果。节点B接收到响应后，继续执行后续逻辑。

服务调用的阻塞：
- 服务调用是同步的，意味着服务客户端会等待服务服务器返回响应结果。在此期间，客户端是阻塞的，不会执行其他操作。

**注意事项**
服务的同步特性：
- 服务通信是同步的，这意味着客户端在等待响应时是阻塞的。如果服务处理时间较长，可能会导致客户端长时间无法执行其他任务。因此，服务适用于那些响应时间较短或需要立即响应的操作。

服务的单一性：
- 每个服务名称在ROS系统中必须是唯一的，确保客户端能正确地找到对应的服务服务器。

超时处理：
- 如果服务服务器无法在合理时间内响应，客户端应考虑超时处理机制，以避免无限等待。

服务的状态和错误处理：
- 服务服务器应能够处理各种可能的请求，包括无效请求，并返回适当的错误信息或状态码。

资源管理：
- 服务服务器可能会处理多个客户端的请求，需要确保其资源（如计算资源、内存）能够支持高并发的请求。

服务和主题的选择：
- 服务通信适用于那些需要明确请求-响应模式的操作。而主题适用于持续数据流的通信。根据需求选择合适的通信机制。

### 动作
动作通信机制特别适用于那些需要较长时间才能完成的任务，并且可能需要在执行过程中提供反馈或取消任务的情况。
**动作通信的过程和原理**
动作（Action）通信基于客户端-服务器模型，但相比服务（Service）通信，它提供了更丰富的功能和灵活性，特别适用于异步、长时间执行的任务。

动作的组成：
- 动作由三个主要部分组成：
  - 目标（Goal）：客户端发送的请求，用来指示服务器要执行的任务。
  - 反馈（Feedback）：在任务执行过程中，服务器定期向客户端发送反馈信息，告知任务的当前状态或进度。
  - 结果（Result）：任务完成后，服务器向客户端发送的最终结果，告知任务的成功或失败及相关数据。

动作服务器（Action Server）：
- 动作服务器是执行特定任务的节点。它接收来自客户端的目标，开始执行任务，并在任务进行过程中提供反馈信息。任务完成后，它会发送结果给客户端。
- 动作服务器支持任务的取消操作，允许客户端在任务执行过程中请求取消操作。

动作客户端（Action Client）：
- 动作客户端是发起任务请求的节点。它向动作服务器发送目标，并可以选择等待任务完成，也可以在任务进行过程中接收反馈，或在必要时取消任务。

ROS Master：
- ROS Master 负责动作服务器和客户端之间的匹配，就像在服务和主题通信中一样，动作服务器在启动时会向ROS Master注册，客户端可以通过ROS Master查找相应的动作服务器。

**动作通信的基本过程**
动作定义：
- 动作通过ROS中的.action文件定义。该文件描述了目标、反馈和结果的结构。例如，一个导航动作可能包括目标位置（目标）、当前机器人位置（反馈）和最终导航状态（结果）。

动作服务器创建：
- 节点A创建并注册一个动作服务器，向ROS Master注册该动作的名称，并定义处理目标、提供反馈和返回结果的函数。

动作客户端创建：
- 节点B创建一个动作客户端，并指定要与哪个动作服务器进行通信。

发送目标：
- 节点B通过客户端向节点A的动作服务器发送目标。节点A开始执行任务，并在执行过程中提供反馈。

接收反馈：
- 节点B可以选择接收并处理反馈信息，以获取任务的执行进度。

任务完成：
- 任务完成后，节点A将结果发送给节点B。节点B可以根据结果执行后续操作。

取消任务：
- 如果节点B在任务执行过程中需要取消任务，可以向节点A发送取消请求，节点A将中止任务的执行并发送取消确认。

注意事项
- 动作的异步特性：
  - 动作通信是异步的，这意味着客户端在发送目标后，不需要阻塞等待结果，可以同时处理其他任务。这非常适用于需要长时间运行的任务。

反馈的重要性：
- 动作的反馈机制允许客户端在任务执行过程中了解进展情况，能够根据反馈信息做出调整或决定是否继续任务。

取消操作：
- 动作允许在任务执行过程中取消任务，这在处理可能需要改变计划的任务时非常有用。客户端应合理使用取消功能，避免不必要的资源浪费。

状态管理：
- 动作服务器需要良好的状态管理，以便在任务执行过程中正确地处理目标、反馈和取消请求。

超时和重试机制：
- 对于可能会因为各种原因而未完成的任务（如网络延迟、硬件故障），客户端应设计合理的超时和重试机制，以确保系统的稳定性和鲁棒性。

**适用场景**
动作通信特别适用于以下场景：
- 导航：如机器人在未知环境中导航，需要不断提供当前位置反馈，并可能在某些情况下取消导航任务。
- 复杂操作任务：如机械臂执行一系列操作步骤，需要实时反馈和可能的中止。
- 数据处理任务：如数据分析或传感器数据处理，需要较长时间才能完成，并且可能需要在过程中提供进度反馈。
## prediction