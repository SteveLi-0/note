# protobuf
## 1. 编码方式
### 1.1 变长编码
 varints是一种将一个整数序列化为一个或者多个Bytes的方法。**越小的整数，使用的Bytes越少**。Varints规则如下：
 
- 每个Bytes的最高位(msb)是标志位。如果该值为1，表示该Bytes后面还有其他Byte；如果该位为0，表示该Byte是最后一个Byte。
- 每个Byte的低7位是用来存数值的位。
- Varints方法使用**小端字节序**(反解数值的时候后面的字节放前面)

**example**

1. 数值：255
2. 二进制： 1111 1111
3. Bytes：1111 1111 0000 0001 （小端）
4. 结果：111 1111 000 0001 （小端）
5. 结果：000 0001 111 1111 （大端）

```
数值200
c801(小端)
在Varints规则，二进制：1100 1000 0000 0001 0001010100111 (小端)

第一个字节8位是 1100 1000，最高位是1，后面还有更多字节；第一个字节内容是后7位即100 1000；

第二个字节8位是 0000 0001，最高位是0，后面没有更多字节；第二个字节内容是后7位即 000 0001；
小端字节序
100 1000  000 0001

大端字节序
000 0001 100 1000      11001000（200）
```

### 1.2 protobuf 编码

- message由一个个字段组成，一个字段的完整的二进制描述即<<编号,传输类型>,值>通常称为一个`field`，如下图。 

![field](pic\field.PNG)

![pb编码](pic\pb-tag.PNG)

- Tag的组成是“field_num << 3 | wire_type”(也称为每个filed的key或者键)。
- 字段编号(field_num): XXX.proto文件中每个字段的编号
- 传输类型(wire_type): 每个字段都有一个对应的字段(传输)类型，如下表：
![wire type](pic\wire-type.PNG)

#### 对于 传输类型 0 1 5 来说

- 16进制： a00601
- 2进制：  1010 0000 0000 0110 0000 0001
- 小端tag： 010 0000  000 0110
- 大端tag： 000 0110  010 0000 
- 字段编号：1100100 
- 传输类型： 000
- 值：      0000 0001

其他细节：
- 对于传输类型 0 来说，值部分：无符号和正数是变长编码，负数用的是改进的zigzag编码。
- 对于传输类型 1 5 来说，值部分：64bits 342bits

#### 对于 传输类型 2 来说

- 十六进制：12087375706572626169
- 二进制小端tag：0001 0010 0000 1000
- 对应大端：001 0010 （只有一个字节）
- 前五位字段编号： 0010 --> 2
- 后三位传输类型： 010  --> 2
- length(变长编码): 000 1000 --> 8
- value: ASCII码 01110011 -- 115 -- s
- .....

# 2. 反射
获得protobuf的元数据，需要用到反射。
- 序列化库用到了编码。
- 特征库用到了反射。

## 2.1 元数据
- 反射就是获取系统、程序的元数据。（系统程序的本身的信息）
- .proto 存储protobuf的元数据。
- 其他终端根据元数据构建proto定义的一些message描述，动态构建出proto对象，然后把数据赋值给对象。